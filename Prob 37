Minimum Spanning Tree by Kruskal Algorithm

class DisjointSet {
    vector<int> parent, sz;

public:
    DisjointSet(int n) {
        parent.resize(n);
        sz.assign(n, 1);
        iota(parent.begin(), parent.end(), 0);
    }

    int findUPar(int x) {
        if (parent[x] == x) return x;
        return parent[x] = findUPar(parent[x]);
    }

    // Returns true if merged (i.e., were in different sets)
    bool unionBySize(int a, int b) {
        a = findUPar(a);
        b = findUPar(b);
        if (a == b) return false;
        if (sz[a] < sz[b]) swap(a, b);
        parent[b] = a;
        sz[a] += sz[b];
        return true;
    }
};
class Solution {
  public:
    int spanningTree(int V, vector<vector<int>>& edges) {
        // edges[i] = {u, v, w}
        vector<array<int,3>> es;
        es.reserve(edges.size());
        for (auto &e : edges) {
            es.push_back({e[2], e[0], e[1]}); // sort by weight: {w, u, v}
        }
        sort(es.begin(), es.end()); // increasing weight
    
        DisjointSet ds(V);
        long long mstWt = 0;
    
        for (auto &e : es) {
            int w = e[0], u = e[1], v = e[2];
            if (ds.unionBySize(u, v)) {
                mstWt += w;
            }
        }
        return (int)mstWt;
        
    }
};
